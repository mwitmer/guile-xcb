\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename guile-xcb.info
@settitle The Guile XCB Manual 1.0
@c %**end of header

@copying
This manual is for Guile XCB, version 1.0.

Copyright @copyright{} 2013 Mark Witmer.

@quotation
   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."
@end quotation
@end copying

@dircategory The Algorithmic Language Scheme
@direntry
* Guile XCB: (guile-xcb).    An X11 Client for Guile
@end direntry

@titlepage
@title Guile XCB
@subtitle An X11 Client for Guile
@author Mark Witmer

@c  The following two commands
@c  start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying

@end titlepage

@c So the toc is printed at the start.
@contents

@ifnottex
@node Top
@top Guile XCB

This manual is for Guile XCB, version 1.0.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

Guile XCB is a Guile Scheme implementation of the XML-XCB project,
providing bindings for the core X11 protocol and many of its
extensions.

@end ifnottex

@menu
* Introduction::
* The XCB Data Structures::
* Interacting With the X Server::
* Writing Guile XCB Applications::

* Function Index::

@end menu

@findex

@node Introduction
@chapter Introduction

This chapter provides some background on the basic components used by
Guile XCB.

@menu
* The X Window System::           The foundation of GUIs for Unix and friends
* XCB::                           The X protocol C-language Binding
* Guile::                         GNU's Ubiquitous Intelligent Language for Extenions
* What to Import::                Where to find Guile XCB's procedures

@end menu

@node The X Window System
@section The X Window System

The @uref{http://www.opengroup.org/tech/desktop/x, X Window System, X
Window System} is a feature of many unix-like operating systems that
provides a mechanism for creating and interacting with graphical user
interfaces.

X uses a client-server architecture, in which an X server listens for
input from peripherals like the mouse and keyboard, and draws
graphical elements in windows on the screen. Client applications can
connect to the X server and send requests to query and modify
information about the windows managed by the server. They may also
select user input events and ask to be notified when they occur.

The server and client communicate using the X Protocol, a binary data
transfer format that defines a few basic types of messages or
packets. These include the following:

@itemize @minus
@item
Request: A message sent from the client to the server with the purpose
of manipulating or querying data and devices managed by the server.

@item
Reply: A message sent from the server to the client that contains the
response to a previous request.

@item
Event: A message sent from the server to the client containing
information about a user input or other kind of action for which the
client has requested notification.

@item
Error: A message sent from the server to the client containing
information about an error---normally as a result of a faulty request
sent by the client.
@end itemize

Any application that can properly communicate with an X server using
this protocol can be considered an X client. Likewise, any application
that correctly handles communication with X clients is a valid X
server, although one would expect it to actually draw the windows
requested by the client and recognize and send user input events as
they happen. Additionally, the core X protocol has been joined over
time by a number of extensions, which specify additional behavior and
cabilities for X servers using the same basic transport.

For many years, the typical method for developing an X client involved
using the venerable
@uref{http://www.x.org/releases/X11R7.6/doc/@/libX11/specs/libX11/libX11.html,
Xlib} C library. Xlib does not allow direct access to the X
protocol. Instead, it attempts to provide a more user-friendly
interface on top of it. Xlib also frequently wraps asynchronous server
calls in synchronized code and does not easily accomodate using X
extensions. More shortcoming of using Xlib are amply described
@uref{http://xcb.freedesktop.org/Features, elsewhere}.

@node XCB
@section XCB

To address some of the limitations of Xlib, some developers created
@uref{http://xcb.freedesktop.org/, XCB, XCB} (X protocol C-language
Binding), a lower-level library the directly maps to the X protcol. In
order to do this, they created a set of XML files that thoroughly
describe the X protocol and many of its extensions. A python script
generates C code based on the XML files for sending X requests and
processing replies, events, and errors asynchronously.

The X protocol XML files are of primary interest in this project; they
provide a language-agnostic description of the X protocol that can be
used to generate bindings in a variety of languages.

@node Guile
@section Guile

@uref{http://www.gnu.org/software/guile, Guile} (GNU's
Ubiquitous Intelligent Language for Extensions), is an implementation
of the Scheme programming language with accompanying compiler and
virtual machine. Guile can serve as a standalone environment for
application development or it can be integrated with C/C++
applications as an extension language.

In Guile, Scheme sits on top of a ``compiler tower'' of languages that
ends with compiled virtual machine bytecode. It is possible to
implement a new language in Guile by writing a compiler that
translates the new language into one of the built-in languages.

Guile XCB uses this facility to compile the X protocol XML files into
Scheme code. Once compiled, the core protocol and available extensions
are each represented by a Guile module.

@node What to Import
@section What to Import

The core X protocol is defined in module @code{(xcb xml
xproto)}. Support functions for interacting with the X server are
found in @code{(xcb xml)}. @code{(xcb event-loop)} is an optional
module with procedures and syntax for running an event loop. @xref{The
Event Loop}.

Extensions to the X protocol are found in modules named using the
format @code{(xcb xml ext @var{extension-name})}. @xref{Using
Extensions}. @var{extension-name} can be one of the following:

@code{bigreq}, @code{composite}, @code{damage}, @code{dpms},
@code{dri2}, @code{ge}, @code{glx}, @code{randr}, @code{record},
@code{render}, @code{res}, @code{screensaver}, @code{shape},
@code{shm}, @code{sync}, @code{xc_misc}, @code{xevie}, @code{xf86dri},
@code{xf86vidmode}, @code{xfixes}, @code{xinerama}, @code{xinput},
@code{xkb}, @code{xselinux}, @code{xtest}, @code{xv}, or @code{xvmc}.

Some of these extensions, while supported by Guile XCB, are deprecated
and may not be available with the latest X server versions.

@node The XCB Data Structures
@chapter The XCB Data Structures

Guile XCB compiles the XML specification of the X protocol into a
variety of Scheme record types, procedures, and values.

@menu

* Structures::         XCB Structures in Scheme
* Types::              Sending valid data to the X Server
* Enums and Masks::    How Guile XCB handles C enums

@end menu

@node Structures
@section Structures

Since the original purpose of XCB was to create a C interface based on
the X protocol XML files, the schema of the XML files coincides nicely
with C structures.

Guile XCB defines objects that behave similarly to C structures, and
provides the means for accessing and modifying their values.  For
example, when the following XML from xproto.xml is compiled, the new
module will contain a variable named @code{setup-failed}

@example

<struct name="SetupFailed">
  <field type="CARD8" name="status" /> <!-- always 0 -> Failed -->
  <field type="CARD8" name="reason_len" />
  <field type="CARD16" name="protocol_major_version" />
  <field type="CARD16" name="protocol_minor_version" />
  <field type="CARD16" name="length" />
  <list type="char" name="reason">
    <fieldref>reason_len</fieldref>
  </list>
</struct>

@end example

It is important to note that Guile XCB normalizes symbols from the xml
files to the lowercase, dash-separated format typical in Scheme source
code. Additionally, symbols that were originally in all-caps are
prefixed with the letter x in order to avoid naming collisionss. For
example, the symbol @code{GC} used in xproto.xml is replaced by
@code{xgc} in Guile XCB, @code{CHAR2B} becomes @code{xchar2b}, and so
forth. The underscores found in XCB struct field names are replaced
with dashes.

In a module compiled from the XML definition above,
@code{setup-failed} is a Scheme object the keeps track of information
about SetupFailed structures received from the X server, including
their fields and how they are read and written. An instance of
@code{setup-failed} can be created with the procedure
@code{make-setup-failed}, which takes as arguments values for each of
the fields described above, excluding ``reason_len'' @footnote{Values
for a field that ends in ``_len'' are computed internally}. The last field,
a list with name @code{reason}, is represented as a vector.

@deffn {Scheme Procedure} make-setup-failed status protocol_major_version protocol_minor_version length reason
Create an xcb struct of type @code{setup-failed}.
@end deffn

Fields of an xcb structure instance can be accessed using the
procedure @code{xref}.

@deffn {Scheme Procedure} xref rec field | rec field n
Return the value of field @var{field} in record @var{rec}. In the
second form, return the @var{n}th value of list field @var{field} in
record @var{rec}.
@end deffn

Fields of an xcb structure instance can be modified using the
procedure @code{xset!}.

@deffn {Scheme Procedure} xset! rec field val | rec field n val
Set the value of field @var{field} in @var{rec} to @var{val}. In the
second form, set the @var{n}th element of list field @var{field} in
@var{rec} to @var{val}.
@end deffn

Some fields of an XCB struct contain vectors of characters or
double-width characters. Guile XCB will transparently convert these
values to Scheme strings if they are referenced using the procedure
@code{xref-string}.

@deffn {Scheme Procedure} xref-string rec field | rec field n
Returns the same value as xref, unless the field's type is char[],
xchar2b[], xbyte[], or void[], in which case it will return the value
converted to a Scheme string. The second form of this procedure is
identical to @code{xref}.
@end deffn

Guile XCB will check to ensure that each value conforms to its type
before sending the record to the X server and will cause an error if
any do not. @xref{Types}. Some fields require that a value belong to a
specific enum or mask; their values are specified with symbols rather
than integer values. @xref{Enums and Masks}.

@node Types
@section Types

Since the X protocol is a binary format, an exact number of bytes must
be used to transfer each field of a structure to the X
server. Likewise, the client must know exactly how many bytes to read
for each field of data received from the server. For this reason, the
XML files specify a type for each field in every xcb structure.

Guile XCB associates each type with a predicate to test if a value
belongs to the type, procedures for reading and writing values to/from
a binary port, and optionally an enum or mask containing a list of
possible values. @xref{Enums and Masks}.

To see what types are required in a structure, evalate the name of the
structure at the REPL and the record type printer will display its
field names and types. If the type is followed by an empty pair of
brackets (such as @code{xchar2b[]}), the value must be a vector of
values that satisfy the type.

@menu
* Core Types::
* Derived Types::
@end menu

@node Core Types
@subsection Core Types

Some types are available to all X extensions. For these types, the
user should provide values with the properties described below:

@itemize @minus
@item
CARD8: An unsigned one-byte integer
@item
CARD16: An unsigned two-byte integer
@item
CARD32: An unsigned four-byte integer
@item
BYTE: Same as CARD8; sometimes used in lists for strings
@item
INT8: A signed one-byte integer
@item
INT16: A signed two-byte integer
@item
INT32: A signed four-byte integer
@item
char: A Scheme character in the Latin-1 range (0-255)
@item
void: Same as CARD8, usually used in blobs of binary data
@item
BOOL: @code{#t} or @code{#f}
@end itemize

@node Derived Types
@subsection Derived Types

Each X extension can define more types of its own by combining or
renaming core types in various ways. These include the following:

@itemize @minus
@item
typedef: This is a simple alias for a type. The newly defined type has
all of the same properties as the original.
@item
xidtype: These are 4-byte integers representing handles to objects
managed by the X server. XIDs are created with the procedure
@code{make-new-xid}. @xref{XIDs}.
@item
struct: Each struct also has a type associated with it (identified by
the variable @var{structname}-type) and can be included as the type of a
field in other structs.
@item
union: These types refer to a list of fields much like structures
do. However, the union only contains one value. When the user requests
the value of one of the fields, that single value is converted from
raw bytes to the appropriate field's representation.

@deffn {Scheme Procedure} xunion-ref rec field
Return the data in xcb union instance @var{rec} represented as a value
conforming to the specification of @var{field}.
@end deffn
@end itemize

@node Enums and Masks
@section Enums and Masks

Some fields have an additional property that affects the type of
values they contain. These are @samp{enum}, @samp{mask}, and
@samp{altenum}.

For @samp{enum} fields, rather than providing a number, the user
should provide the symbol that is the name of a value in the specified
enum.  For example, if a field is limited to the enum
@code{backing-store}, the user must provide one of the following
symbols as a value: @code{not-useful}, @code{when-mapped}, or
@code{always}. Guile XCB will not accept integer values for this
value.

@samp{mask} fields use a list of symbols, each one representing a
value from the mask, which are then combined with @code{logior}.

@samp{altenum} fields are like @samp{enum} fields, except that they
accept any integer value within the provided type as well as any
symbol from among the enum keys.

When accessed, values in structs that are associated with enums will
likewise be represented as symbols or lists of symbols. If a value
with a type referencing an altenum is not listed in the enum, the raw
numeric value will be provided instead.

To determine what symbols are present in an enum, consult the XML file
or evalute the name of the enum at the REPL. Clients may also access
the underlying numeric values in a enum with the procedure
@code{xenum-ref}.

@deffn {Scheme Procedure} xenum-ref enum key
Returns the numeric value stored in @var{enum} with key @var{key}.
@end deffn

For fields that are not explicitly marked as using a mask but
nevertheless require values logior'd together, the procedure
@code{xenum-or} is available:

@deffn {Scheme Procedure} xenum-or enum . keys
Return the values associated with @var{keys} in xcb enum @var{enum}
combined with @code{logior}.
@end deffn

@deffn {Scheme Procedure} xenum-keys enum
Return a list of all the keys in the enum.
@end deffn

@deffn {Scheme Procedure} xenum-values enum
Return a list of all the values in the enum.
@end deffn

@node Interacting With the X Server
@chapter Interacting With the X Server

Using the previously described structures as a basis, Guile XCB
provides a simple interface for sending requests to the X server and
receiving replies, errors, and events. Procedures for interacting
with an X server are exported from the module @code{(xcb xml)}.

@menu
* Connecting::         Connecting to the X Server
* Sending Requests::   Putting the X Server to work
* Replies, Events, and Errors: Replies.            Getting data back from the X Server
* Using Extensions::   Going beyond the core X protocol

@end menu

@node Connecting
@section Connecting to the X Server

Connections to the X service are created using the procedure
@code{xcb-connect!}.

@deffn {Scheme Procedure} xcb-connect! [display=(getenv ``DISPLAY'')] [hostname=(gethostname)]
Connect to the X server running on @var{display} and
@var{hostname}. Returns a record of type @code{xcb-connection}, which
is used for further interaction with the X server.
@end deffn

@var{display} should be in the format @samp{:n.p} or simply @samp{:n},
where @var{n} is the display number and @var{p} is a screen number.
When an X server is running, the variable @var{DISPLAY} with the
needed string as its value should be defined in the shell enivronment,
and that value is used by default.

It is safe to use an xcb connection in multiple threads; each
connection has a mutex that blocks other threads from sending or
receiving data from the X server while one thread is doing so.

@deffn {Scheme Procedure} xcb-disconnect! xcb-conn
Close the connection to the X server represented by @var{xcb-conn}
@end deffn

@deffn {Scheme Procedure} xcb-connected? xcb-conn
Returns @code{#t} if the xcb-connection has successfully connected to an X
server and contains a setup value, otherwise returns @code{#f}
@end deffn

@deffn {Scheme Procedure} xcb-connection-setup xcb-conn
If @var{xcb-conn} is connected, returns the setup information provided
by the X server. Returns @code{#f} otherwise.
@end deffn

The setup information is stored in a struct of type @samp{setup},
which is defined in the core X protocol XML file, xproto.xml.

@deffn {Scheme Procedure} xcb-connection-display xcb-conn
Returns the display string used to connect @var{xcb-conn}.
@end deffn

@node Sending Requests
@section Sending Requests

Each request defined in the X protocol and its available extensions is
represented by a Scheme procedure of the same name, with arguments
corresponding to the fields of the X request. Another Scheme procedure
with the suffix ``/c'' is also available which takes an XCB connection
as its first argument. Some requests include optional fields.

@menu
* A Simple Request Example::
* Valueparams::
* Switches::
* XIDs::
* Predefined Values and Helpers::

@end menu

@node A Simple Request Example
@subsection A Simple Request Example

Perhaps sending requests to the X server is best illustrated with an
example from the core X protocol:

@deffn {Scheme Procedure} query-extension name
Send a QueryExtension request to the X server connected to the current
xcb connection, with the value @var{name}. Returns the sequence number
of the request.
@end deffn

By default, X requests are sent using the parameter
@code{current-xcb-connection}. The value of this parameter must be set
to an open XCB connection.

@deffn {Scheme Procedure} current-xcb-connection [xcb-conn]
Sets the value of the @code{current-xcb-connection} parameter to
@var{xcb-conn}, if is provided. Otherwise, returns the value of the
@code{current-xcb-connection} parameter.
@end deffn

The rationale for using a dynamically-scoped parameter is that most
applications will only use one X connection (possibly one per thread),
and requiring every X request to refer to the X connection is
unnecessarily redundant.

An alternative form of each X request, with the suffix ``/c'', is
available, allowing the user to specify the X connection directly:

@deffn {Scheme Procedure} query-extension/c xcb-conn name
Send a QueryExtension request to the X server connected to
@code{xcb-conn} for the extension named @var{name}. Returns the
sequence number of the request.
@end deffn

Guile XCB does not queue requests; they are sent to the X server as
soon as they are ready. However, sending a request to the server does
not immediately result in a reply. In cases where a request has an
associated reply, the user must poll the xcb connection for data until
the reply becomes available. @xref{Replies}.

@node Valueparams
@subsection Valueparams

A common method of specifying optional variables in an X request
involves two fields: a value mask, and a value list. Collectively they
are referred to as a valueparam. For every bit set in the value mask,
the X server will read off an element from the value list.

In the C implementation of XCB, the user has to combine values from an
enum using @code{|} in order to generate the value mask, and then
create a list of values in the correct order to match the bits in the
mask.

The Guile XCB approach is less complicated. XCB defines an enum for
each value mask that gives names to all the possible arguments, and
Guile XCB uses these names to form a set of keyword arguments that can
be passed when creating a request.

The following example demonstrates the use of a valueparam to set a
window's location:

@lisp
(configure-window window #:x 100 #:y 100)
@end lisp

In this example, the possible keyword arguments are defined in the
enum @code{config-window}. @code{#:x} and @code{#:y} are the values
included in this particular request.

All values in a valueparam have the same type (usually CARD32) whether
or not they are logically restricted to a certain type or
enum. However, Guile XCB will automatically convert XIDs to integers,
@code{#t} and @code{#f} to the values 0 and 1, and symbols or lists of
symbols to numeric values from the appropriate enum. Usually the enum
will have the same name as the valueparam field (eg. a symbol provided
as an @code{#:event-mask} argument will be replaced with the
corresponding number in the @code{event-mask} enum).

In some cases, such as the @code{#:bit-gravity} field in
@code{change-window-attributes} (which should be associated with the
@code{gravity} enum), the valueparam field has a different name than
the enum associated with it. Guile XCB will still ``do the right
thing'' if it receives a symbol or symbol list as the value for that
field.

@node Switches
@subsection Switches

In some X requests and replies, more than one value is considered when
determining which optional fields should be included. Valueparams are
insufficient in such cases, so the XCB developers created a more
generalized construct called a `switch,' due to its use of
@code{switch} syntax in the C implementation.

Switches can be present in both requests and replies, adding one
additional field to a xcb structure's record type. This field is an
associative list, where each pair has the name of a conditionally
included field as its car and the corresponding value as its
cdr. Consult the appropriate X extension specification to determine
which fields are expected under which circumstances.

The following example demonstrates the use of a switch in an XKEYBOARD
request:

@lisp
(select-events 12
               '(new-keyboard-notify)
               '(state-notify)
               '(state-notify)
               '(key-actions)
               '(key-actions)
               '((affect-new-keyboard . (keycodes))
                 (new-keyboard-details . (geometry))))
@end lisp

At present, XKEYBOARD is the only extension which uses switches.

@node XIDs
@subsection XIDs

Some requests involve asking the X server to create and manage new
resources. These resources are referred to with unique identifiers
called ``XIDs.'' The client must create the new XIDs that it sends to
the server.

@deffn {Scheme Procedure} make-new-xid [xcb-conn] xcb-type
Generate a new unique identifier for referring to a resource
maintained by the X server connected to @var{xcb-conn} (or
@code{current-xcb-connection}, if it is ommitted). X requests that
instruct the server to create, for example, new Windows or Graphical
Contexts require an XID for the new resource. @var{xcb-type} is an xid
type such as @code{xwindow} or @code{xgc}.
@end deffn

From the point of view of the X server, XIDs are simply 4-byte
integers. When an XID value is created or pulled from an XCB struct
using @code{xref}, it will be associated with its type information (a
name such as xwindow, xfont, xcursor, etc.). This is meant to assist
the user in keeping track of what sort of X resource is associated
with a particular XID number.

Sometimes, due to ommissions in the XCB-XML files, replies from the X
server will store an XID's integer value without the annotation that
it is an XID. In this case, it might be necessary to convert the raw
integer into a typed XID.

@deffn {Scheme Procedure} make-xid n xid-type
Create an XID with of type @var{xid-type} with id number @var{n}.
@end deffn

On other occasions, it can be useful to extract the integer value from
an XID.

@deffn {Scheme Procedure} xid->integer xid
Return the raw integer value of @var{xid}.
@end deffn

It can also be useful to compare XIDs:

@deffn {Scheme Procedure} xid= xid1 xid2
Returns @code{#t} if the integer value and type of @var{xid1} and
@var{xid2} are the same (@code{=} and @code{eq?}, respectively).
@end deffn

Applications that require more XIDs than are initially available may
enable and use the XC_MISC X extension, if it supported by the X
server. @xref{X Extensions Used by Guile XCB}.

@node Predefined Values and Helpers
@subsection Predefined Values and Helpers

Because the X protocol is a binary protocol and everything must be
expressed numerically, managing complex values can be unwieldy. Guile
XCB provides a few procedures and values to simply these tasks.

@deffn {Scheme Variable} xcb-current-time
Alias for the value zero to use in fields that describe X timestamps;
causes the X server to use the current time for the field's value.
@end deffn

@deffn {Scheme Procedure} xcb-none xid-type
Create an XID for @var{xid-type} with an actual value of zero; for use in
fields of X requests that accept ``none'' as an option instead of a
defined XID.
@end deffn

@deffn {Scheme Procedure} xcb-event->vector [xcb-conn] event

Convert @var{event} into a character vector for use in sending a
@code{send-event} request on connection @var{xcb-conn} (or
@code{current-xcb-connection} if it is ommitted).

@end deffn

@node Replies
@section Replies, Events, and Errors

Many X requests elicit replies from the X server. Because the X
protocol is asynchronous, the client must check its connection with
the server periodically to see if any replies, events, or errors
have arrived.

@deffn {Scheme Procedure} poll-xcb-connection xcb-conn [async?=@code{#f}]
Receive the next reply, event, or error from the X server connected to
@var{xcb-conn}. If @var{async?} is @code{#t}, the procedure will
return the values @code{none} and @code{#f} if no data is immediately
available. Otherwise the procedure will block for a response.

When this procedure does receive data from the X server, it returns
two values---the first is a symbol (@code{reply}, @code{error}, or
@code{event}) indicating what kind of data was received from the
server. The second value is a vector containing the data received from
the server. The vector can be referenced directly or through the
procedures @code{xcb-struct}, @code{xcb-data}, and
@code{xcb-sequence-number}.
@end deffn

@deffn {Scheme Procedure} xcb-struct data
Returns the XCB struct (i.e. @code{key-press-event},
@code{query-extension-reply}, etc.) for a piece of data sent by
the X server.
@end deffn

@deffn {Scheme Procedure} xcb-data data
Returns the instance of an XCB struct for a piece of data sent by the
X server.
@end deffn

@deffn {Scheme Procedure} xcb-sequence-number data
Returns the sequence number for a piece of data sent by the X
server. Note that this field is not present for events; if they have a
sequence number, it is included as one of the fields of the XCB struct
itself.
@end deffn

A reply from the X server uses an xcb struct with a name in the form
@code{@var{request-name}-reply}, such as @code{query-extension-reply}
or @code{get-window-attributes-reply}.

When something goes wrong while the X server processes a request,
either because of faulty data provided by the client or an internal
error, the X server may send an error message in place of a reply.
Errors have names in the form @code{@var{error-name}-error}, such as
@code{alloc-error} and @code{value-error}.

Events have names in the form @code{@var{event-name}-event}, such as
@code{key-press-event} or @code{focus-in-event}.

The @code{xcb-sequence-number} field of a call to
@code{poll-xcb-connection} can be matched to the sequence number
returned by a previous X request function.

Using @code{poll-xcb-connection} directly can be
cumbersome. @pxref{The Event Loop} for a more convenient abstraction.

@node Using Extensions
@section Using Extensions

The core X protocol has been joined over time by a number of
extensions, which provide much of the actual functionality required by
modern X applications. Many of these extensions are available in Guile
XCB. @xref{What to Import}. Some are used by the Guile XCB code
itself, and the rest can be enabled as necessary.

@menu
* Enabling X Extensions::
* X Extensions Used by Guile XCB::
@end menu

@node Enabling X Extensions
@subsection Enabling X Extensions

If the X server includes an extension to the core protocol, the client
may make use of it by calling a procedure defined in the extension's
module.

@deffn{Scheme Procedures} xcb-enable-@var{extension-name}! reply

Based on @var{reply}---an instance of
@code{query-extension-reply}---enable the X extension with name
@var{extension-name} for @code{current-xcb-connection}.

Returns @code{#t} if the extension was successfully enabled, and
@code{#f} otherwise.

Extension names correspond to the value of the @code{header} attribute
in the root node of an X protocol XML file. Specific procedures of
this type are named @code{xcb-enable-bigreq!},
@code{xcb-enable-xc_misc!}, and so on. Note that extension names are
not normalized to the standard Scheme variable name format.
@end deffn

@deffn{Scheme Procedure} xcb-enable-@var{extension-name}!/c xcb-conn reply
Same as the procedure described above, but @var{xcb-conn} must also be provided.
@end deffn

A client can check to see if extensions have been enabled for a given
xcb connection:

@deffn {Scheme Procedure} xcb-connection-has-extension? xcb-conn ext-name
Return @code{#t} if extension @var{ext-name} is enabled on connection
@var{xcb-conn}.
@end deffn

Note that Guile XCB does not perform any version negotiation with the
server; enabling an extension simply provides the xcb connection with
the opcode, first event number, and first error number necessary for
further interaction with the extension.

The name for an extension that should be passed to the X server in a
@code{query-extension} request can be found with the following method:

@deffn{Scheme Procedure} get-extension-info key

Look up the information needed to enable extension with header name
@var{key}, a symbol such as @code{randr}, @code{xc_misc}, etc.,
corresponding to the @code{header} attribute in the root tag of an
XML-XCB file.

Returns a pair of values; the car is a string that can be passed as an
argument to @code{query-extension}, and the cdr is the procedure for
enabling the extension, as described previously.

@end deffn

Most X extensions will export some bindings that conflict with those
exported by other X extensions. Modules that import extensions with
conflicting definitions should use @code{#:rename} or @code{#:replace}
as appropriate. @inforef{Using Guile Modules, Using Guile Modules,
guile}.

@node X Extensions Used by Guile XCB
@subsection X Extensions Used by Guile XCB

Guile XCB can make use of three X extensions internally to provide a
more flexible client library to its users. These extensions are not
enabled by default but can be enabled by a program if their use is
required.

@itemize
@item
BIG-REQUESTS: In the core X protocol, requests are limited in size to
around 260KB. To support certain extensions that require longer
requests, the big requests extension was created to allow requests up
to 16GB. Guile XCB will use big requests when necessary if they are
enabled.

@deffn {Scheme Procedure} enable-big-requests! [xcb-conn] enable
Sets the request size limit for @var{xcb-conn}, or
@code{current-xcb-connection} if it ommitted, to the value of
@var{enable}'s @code{maximum-request-length} field. @var{enable}
should be a reply to the big request extension's @code{enable}
request.
@end deffn

@item
XC_MISC: The X server supports a limited number of XIDs per
connection; if the supply of XIDs runs out, @code{make-new-xid} will
invoke a procedure associated with the xcb connection that should
return the reply to an XC_MISC @code{get-xidrange} request.

@deffn {Scheme Variable} set-on-xid-range-exhausted! xcb-conn proc
Sets the xid range exhaustion procedure for @var{xcb-conn} to
@var{proc}, which will receive @var{xcb-conn} as its argument, and
must return an instance of @code{get-xidrange-reply}.
@end deffn

@item
Generic Event Extension: Standard X events are limited to 32 bytes in
length and there are also a limited quantity of error opcodes
available. To circumvent both of these limitations, the Generic Event
Extension turns the event with opcode 35 into a special generic event,
which receives a standard header describing the contents of more
specific events, which can be longer than the original 32-byte limit.
If the extension is enabled, Guile XCB can handle generic events,
although they are only output by a small subset of the available
extensions.
@end itemize

@node Writing Guile XCB Applications
@chapter Writing Guile XCB Applications

The previously defined procedures for sending and receiving X data are
all one needs to write X applications. However, polling the connection
and handling replies, errors, and events manually can be error-prone
and cumbersome. Guile XCB provides a basic framework for running an
event loop and describing in advance how data from the X server will
be handled.

@menu
* The Event Loop::
* Built-in XCB Documentation::
@end menu

@node The Event Loop
@section The Event Loop

There are no strict requirements regarding the format of an X
application, and Guile XCB does not impose any on its users. However,
one very common design is to run a loop that constantly polls the X
connection for events, errors, and replies and sends requests to
update the X server state depending on the data it receives.

One implementation of an event loop and several asynchronous X request
functions to go along with it are found in the @code{(xcb event-loop)}
module. @xref{What to Import}.

@menu
* Starting an Event Loop::
* Listening to the X Server::
* Solicit and Notify::
@end menu

@node Starting an Event Loop
@subsection Starting an Event Loop

The procedure @code{xcb-event-loop} provides a framework for running
an asynchronous event loop.

@deffn {Scheme Procedure} xcb-event-loop xcb-conn proc
Execute thunk @var{proc} in a dynamic scope where
@code{current-xcb-connection} is bound to @var{xcb-conn}, and an event
loop for handling calls to the @code{solicit}/@code{notify} procedures
is in place. @xref{Solicit and Notify}.

@end deffn

Two macros are provided as wrappers for @code{xcb-event-loop}:

@deffn {Scheme Syntax} with-connection xcb-conn stmt ...
Creates a thunk with body @var{stmt} ... and runs an event loop until
the thunk is completed.
@end deffn

@deffn {Scheme Syntax} loop-with-connection xcb-conn stmt ...
Creates a thunk with body @var{stmt} ... and runs an event loop until
the thunk is completed and the xcb connection is also disconnected.
@end deffn

@node Listening to the X Server
@subsection Listening to the X Server

By default, errors from the X server are thrown as guile errors. To
prepare an event loop with a different error-handler, use the
following method:

@deffn{Scheme Procedure} event-loop-prepare! xcb-conn error-handler

Prepares @var{xcb-conn} for use in an event loop. @var{error-handler}
is a procedure that will be called when the X server sends an
error. It takes two arguments: @var{resume}, a procedure that, when
called, will return control back to the event loop, and @var{data}, a
vector returned from @code{poll-xcb-connection}.

It is only necessary to call this procedure before calling
@code{xcb-event-loop} if @var{error-handler} is provided, or if
reply/event handler procedures are going to be attached to the
connection before the event loop starts. Otherwise, @var{xcb-conn}
will automatically be prepared with the default error handler at that
point.

@end deffn

@deffn{Scheme Procedure} event-loop-prepared? xcb-conn

Returns @code{#t} if @var{xcb-conn} is prepared for use in an event
loop.

@end deffn

Once an XCB connection is prepared for use in an event loop, the
following procedures can be used to define its behavior when data is
received from the X server. These procedures can be called before an
event loop or inside of one. The argument @var{xcb-conn} is optional;
omitting it will cause the value of @code{current-xcb-connection} to
be used instead.

@deffn{Scheme Procedure} listen! [xcb-conn] event-type tag proc [guard]

Add procedure @var{proc} to the list of procedures that may be called
when an event of type @var{event-type} is received by
@var{xcb-conn}. @var{proc} takes one argument, @var{event}, which is
an XCB structure corresponding to the event from the server.

@var{tag} is any value that can uniquely identify the procedure,
making it easier to later remove the procedure from the list. Any
procedure already associated with @var{tag} for the given
@var{event-type} will be overridden by the new one.

@var{guard}, if present, should be a predicate that takes the same
argument as @var{proc} and returns @code{#t} if @var{proc} should be
called, or @code{#f} if the event does not match some set of criteria
and @var{proc} should be skipped.

@end deffn

@deffn{Scheme Procedure} unlisten! [xcb-conn] event-type tag

Removes the event handler procedure associated with value @var{tag}
from the list of event handlers on event type @var{event-type} for xcb
connection @var{xcb-conn}.

@end deffn

@deffn{Scheme Procedure} listen-default! [xcb-conn] proc

Installs @var{proc} as the default procedure to call when an event is
not otherwise handled by @var{xcb-conn}.

@var{proc} will be called with the event as its argument; if the event
is not recognized by the connection, perhaps because it pertains to an
extension that has not been enabled, a bytevector containing the raw
binary data from the server will be passed instead.

@end deffn

@deffn{Scheme Procedure} unlisten-default! [xcb-conn]

Removes the default event handler from @var{xcb-conn}.
@end deffn

@deffn{Scheme Procedure} reply-listen! [xcb-conn] sequence-number reply-proc

When a reply with @var{sequence-number} is received by @var{xcb-conn},
calls @var{reply-proc} with the reply as an argument. The handler is
removed after it has been called.

@end deffn

The following syntax is useful for creating a set of related,
self-contained, and self-managing event listeners:

@deffn{Scheme Syntax} create-listener (stop! reset! reset-expr ...) ((event-struct event #:field value ...) body body* ...) ...

Adds a set of event listeners to the current xcb connection. Each
@var{event-struct} is an XCB struct type for an event and @var{event}
is bound to the event within the accompanying expressions @var{body
body* ...}.

@var{#:field} is a keyword for a field of the event struct
(eg. #:window, #:event, #:count, etc.), and @var{value} is the
required value for that field. There can be any number of
@var{#:field}/@var{value} pairs. The body expressions will only be
evaluted if the fields of the event match the required values.

@var{stop!} is the name for a procedure that can be called anywhere in
a body expression that removes the listeners from the connection.

@var{reset!} is the name for a procedure that executes the expressions
@var{reset-expr ...} and then reinstates the listeners. It is called
once to start the listeners when the macro is first evaluated.

The macro returns @var{stop!} and @var{reset!} as two values.
@end deffn

@deffn{Scheme Syntax} create-listener ([stop!]) ((event-struct name) body body* ...) ...

This is shortened syntax for cases where @var{reset!} is not needed in
@code{create-listener}. @var{stop!} may also be ommitted.

@end deffn

@deffn{Scheme Syntax} create-tagged-listener tag ...

Identitical to @code{create-listener}, but requires an
additional argument @var{tag}, which will is used as the tag argument
in @code{listen!}/@code{unlisten!}.

Use @code{create-tagged-listener} if newly created listeners are meant
to replace pre-existing ones with the same tag.
@end deffn

@node Solicit and Notify
@subsection Solicit and Notify

Most applications need more structure than what a set of isolated,
unrelated event handlers can provide. Consider, for example, a user
interface where typing a key on some widget brings up a message box
that the user must click in order to proceed. The original keypress
will launch one event handler, which then has to wait for a mouse
click.  It becomes necessary to return to the event loop, receive and
handle the mouse click event, and then resume the keypress handler
based on the mouse click handler's result.

One approach is to create a new function, called a @emph{callback},
and queue it to run when the mouse click event happens. The keypress
handler finishes, and control goes back to the event loop. When the
mouse click takes place, the callback gets invoked and finishes the
work that the keypress event handler started.

The callback approach is a common one and is often very
useful. However, it can sometimes lead to a very large nested mess of
callbacks within callbacks.

Thankfully, Guile includes some sophisticated control flow
maniuplation mechanisms that eliminate the need for callbacks in most
places. Guile XCB's event loop makes use of delimited continuations
and prompts to make each handler function behave as if it were running
in its own thread without any of the associated concurrency
challenges. @inforef{Prompts, Prompts, guile}.

There are some caveats to this approach. First, it only
@emph{emulates} multithreading---it is not the real thing. While an
event handler is running, no new events will be processed. Any
long-running operations that might make the application unresponsive
should be handled by an actual separate thread.

Secondly, delimited continuations save pending function calls and
restore them when they are called. Normally this works fine, but some
functions set up ``continuation barriers,'' and can't be restored. If
the function @code{solicit} described below gets called when function
calls like @code{run-hook}, @code{hash-for-each}, or @code{force} are
on the stack somewhere, a later call to @code{notify} for the
solicited tag will cause an error. @inforef{Continuation Barriers,
Continuation Barriers, guile}.

With those warnings in mind, it is still possible to write a flexible
and expressive asynchronous application using the following
procedures:

@deffn{Scheme Procedure} solicit tag [proc]

If @var{proc} is provided, set @var{proc} up as a callback that will
be invoked when some other procedure calls @code{notify} with a value
for @var{tag}. The value is @var{proc}'s only argument.

Otherwise, returns control back to the event loop until some other
handler function calls @code{notify} with the same @var{tag}. At that
point, this @code{solicit} returns the value and the procedure
continues as normal.

If a handler has already called @code{notify} and the tag was not yet
solicited at that time, the oldest stored value will be consumed by
this call to @code{solicit}.

If another procedure has already solicited @var{tag}, it will
never complete. Multiple @code{solicits} do not queue up.

@end deffn

@deffn{Scheme Procedure} notify tag val

Notifies the event loop of the presence of value @var{val} marked with
@var{tag} and finishes running the pending procedure that has called
@code{solicit} on @var{tag}, if it exists. Otherwise, the value will
be queued for later calls to @code{solicit} for @var{tag}.

@end deffn

@deffn{Scheme Procedure} make-tag datum

Creates a unique object based on @var{datum} that can be used as a tag
for calls to @code{solicit} and @code{notify}.

@end deffn

A few procedures and macros built on @code{solicit} and @code{notify}
can be used for more XCB-specific tasks:

@deffn{Scheme Procedure} delay-reply proc . args

Call XCB request procedure @var{proc} on the current xcb connection
with arguments @var{args}. Returns a tag that, when used in a call to
@code{solicit}, will yield the corresponding reply for the request. Do
not use this procedure for a request that does not receive a reply
from the server, or else the procedure that called it will never
resume.

@end deffn

@deffn{Scheme Procedure} delay-enable-extension extension-key

Sends a @code{query-extension} request to the server and, if the
extension is present, enables that extension for the current xcb
connection when the reply arrives. Returns a tag for use with
@code{solicit} to defer to the event loop until the reply arrives.

@end deffn

@deffn{Scheme Procedure} reply-for proc . args

Calls @code{delay-reply} on the given arguments and then immediately
solicits and returns the reply.

@end deffn

@deffn{Scheme Syntax} with-replies ((reply proc arg ...) ...) stmt stmt* ...

Calls each XCB request procedure @var{proc} with its associated
@var{arg} list as arguments. When all of the replies are received,
they are each bound to the corresponding symbol @var{reply} and used
as arguments to call a procedure with body @var{stmt stmt* ...} .

Returns a tag that can be used in a call to @code{solicit} to wait for
the procedure to execute and then return its result.

@end deffn

@node Built-in XCB Documentation
@section Built-in XCB Documentation

In addition to providing a specification of the X protocol, some of
the X protocol XML files also contain documentation. Guile XCB allows
the user to interactively peruse this documentation, and provides some
helpful documentation features of its own.

@menu
* XML Documentation::
* Scheme Documentation::
@end menu

@node XML Documentation
@subsection XML Documentation

Documentation of items in the X protocol XML files can have two forms:
brief, which summarizes the item in one or two sentances, and full,
which can include detailed information as well as examples and
cross-references.

@deffn {Scheme Procedure} document-full header item-type item
Display the full documentation for an XCB element @var{name} of type
@var{item-type} (@code{enum}, @code{request}, @code{reply},
etc.). @var{header} is an all lower-case symbol identifying the
extension to search for documentation (@code{xproto}, @code{bigreq},
@code{glx}, etc.). @var{header} and @var{item-type} are symbols and
@var{item} is the actual scheme object to document (use the request
procedure with @var{item-type} @code{reply} to see documentation for
the reply).
@end deffn

@deffn {Scheme Procedure} document-brief header item-type item
Display brief documentation for an XCB element. Arguments are the same
as in @code{document-full}.
@end deffn

Unfortunately, the XCB documentation for extensions is far from
complete, though much of the core protocol is documented. The examples
provided are also written in C but translate easily enough to Scheme.

@node Scheme Documentation
@subsection Scheme Documentation

Information about various XCB requests, structures, types, enums, and
so on can be viewed by evaluating the name of the variable at the
REPL. The record type printers output, for example, a list of fields
and types for structures, and a list of keys and values for enums.

The underlying structure used to send a request to the server has the
name REQUEST-NAME-struct (@code{create-window-struct},
@code{query-extension-struct}, etc.). Evaluating this structure at the
REPL will show the required fields for the request and their types.

@node Function Index
@unnumbered Function Index

@printindex fn

@bye
